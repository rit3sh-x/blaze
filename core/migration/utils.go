package migration

import (
	"fmt"
	"strings"

	"github.com/rit3sh-x/blaze/core/ast/class"
	"github.com/rit3sh-x/blaze/core/ast/field"
	"github.com/rit3sh-x/blaze/core/constants"
)

func (me *MigrationEngine) generateColumnDefinition(field *field.Field, cls *class.Class) (string, bool) {
	columnName := field.GetName()
	dataType, err := me.mapToPGType(field, cls)
	if err != nil {
		return "", false
	}

	var parts []string
	parts = append(parts, applyQuotes(columnName), dataType)

	if field.IsArray() {
		parts[1] = parts[1] + "[]"
	}

	if !field.IsOptional() {
		parts = append(parts, "NOT NULL")
	}

	if field.HasDefault() {
		defaultValue := me.generateDefaultValue(field)
		if defaultValue != "" {
			parts = append(parts, defaultValue)
		}
	}

	if field.IsUnique() {
		parts = append(parts, "UNIQUE")
	}

	return strings.Join(parts, " "), true
}

func (me *MigrationEngine) mapToPGType(field *field.Field, cls *class.Class) (string, error) {
	baseType := field.GetBaseType()

	if constants.IsScalarType(baseType) {
		switch constants.ScalarType(baseType) {
		case constants.INT:
			return "INTEGER", nil
		case constants.BIGINT:
			return "BIGINT", nil
		case constants.SMALLINT:
			return "SMALLINT", nil
		case constants.FLOAT:
			return "DOUBLE PRECISION", nil
		case constants.NUMERIC:
			return "NUMERIC", nil
		case constants.STRING:
			if field.HasDefault() && field.AttributeDefinition.DefaultValue != nil {
				if callback, ok := field.AttributeDefinition.DefaultValue.Value.(string); ok {
					if callback == constants.DEFAULT_UUID_CALLBACK {
						return "UUID", nil
					}
				}
			}

			if !field.HasRelation() {
				if cls != nil {
					for _, otherField := range cls.Attributes.Fields {
						if otherField.HasRelation() && otherField != field {
							relation := otherField.AttributeDefinition.Relation
							if relation != nil {
								for _, fromField := range relation.From {
									if fromField == field.GetName() {
										referencedClass := me.toSchema.GetClassByName(relation.ToClass)
										if referencedClass != nil {
											for i, toFieldName := range relation.To {
												if i < len(relation.From) && relation.From[i] == field.GetName() {
													for _, referencedField := range referencedClass.Attributes.Fields {
														if referencedField.GetName() == toFieldName {
															if referencedField.GetBaseType() == "String" &&
																referencedField.HasDefault() &&
																referencedField.AttributeDefinition.DefaultValue != nil {
																switch v := referencedField.AttributeDefinition.DefaultValue.Value.(type) {
																case string:
																	if v == constants.DEFAULT_UUID_CALLBACK {
																		return "UUID", nil
																	}
																}
															}
															break
														}
													}
												}
											}
										}
										break
									}
								}
							}
						}
					}
				}
			}

			return "TEXT", nil
		case constants.BOOLEAN:
			return "BOOLEAN", nil
		case constants.DATE:
			return "DATE", nil
		case constants.TIMESTAMP:
			return "TIMESTAMP(3)", nil
		case constants.JSON:
			return "JSONB", nil
		case constants.BYTES:
			return "BYTEA", nil
		case constants.CHAR:
			return "CHAR(1)", nil
		}
	}

	if me.toSchema.GetEnumByName(baseType) != nil {
		return baseType, nil
	}

	return "", fmt.Errorf("unknown type: %s", baseType)
}

func (me *MigrationEngine) generateDefaultValue(field *field.Field) string {
	defaultValue := field.AttributeDefinition.DefaultValue
	if defaultValue.IsCallback() {
		callback := defaultValue.GetValue().(string)
		switch callback {
		case constants.DEFAULT_NOW_CALLBACK:
			return "DEFAULT CURRENT_TIMESTAMP(3)"
		case constants.DEFAULT_UUID_CALLBACK:
			return "DEFAULT gen_random_uuid()"
		case constants.DEFAULT_AUTOINCREMENT_CALLBACK:
			return "GENERATED BY DEFAULT AS IDENTITY"
		}
	}

	if defaultValue.IsArray {
		if elements, ok := defaultValue.GetArrayElements(); ok {
			var values []string
			for _, elem := range elements {
				values = append(values, me.formatValue(elem))
			}
			return fmt.Sprintf("ARRAY[%s]", strings.Join(values, ", "))
		}
	}

	return fmt.Sprintf("DEFAULT %s", me.formatValue(defaultValue.GetValue()))
}

func (me *MigrationEngine) formatValue(value interface{}) string {
	switch v := value.(type) {
	case string:
		return fmt.Sprintf("'%s'", strings.ReplaceAll(v, "'", "''"))
	case bool:
		if v {
			return "TRUE"
		}
		return "FALSE"
	case int, int64, float64:
		return fmt.Sprintf("%v", v)
	default:
		return fmt.Sprintf("'%v'", v)
	}
}

func (me *MigrationEngine) mapConstraintAction(action string) string {
	switch action {
	case constants.ON_DELETE_CASCADE:
		return "CASCADE"
	case constants.ON_DELETE_RESTRICT:
		return "RESTRICT"
	case constants.ON_DELETE_SET_NULL:
		return "SET NULL"
	case constants.ON_DELETE_NO_ACTION:
		return "NO ACTION"
	default:
		return "NO ACTION"
	}
}

func applyQuotes(input string) string {
	return fmt.Sprintf(`"%s"`, input)
}